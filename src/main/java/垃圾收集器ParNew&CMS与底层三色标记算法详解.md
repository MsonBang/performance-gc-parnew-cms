## 垃圾收集算法
    分代收集算法
    标记-复制算法
    标记-整理算法
    标记-清除算法
    
    1.分代收集理论：
        (1) 当前虚拟机垃圾收集都采用分代收集算法，这种算法只是根据对象存活周期的不同将内存分为几块。
            一般Java堆分为新生代和老年代，因此根据各个年代的特点选择合适的垃圾收集算法。
        (2) 比如在新生代，每次收集都会有大量对象99%死去，所以可以选择复制算法，只需要一些复制成本就可以完成每次垃圾收集。
        (3) 老年代存活几率比较高，所以选择 "标记-清除" 或者 "标记-整理" 算法进行垃圾收集。速度比复制慢10倍以上。
    
    2.标记-复制算法
        为了解决效率问题，"复制"收集算法出现了。
        将内存分为两块相同大小。每次使用其中一块。
        当这一块使用完成后，将剩余存活对象复制到另一块，然后把使用过的空间清理掉。
        这样每次都是对内存空间的一半进行回首。
        
    3.标记-清除算法
        主要包括标记和清除两个阶段：
            标记存活的对象，统一回收所有未被标记的对象。
            也可以标记所有需要回收的对象，统一回收标记的对象。
        两个问题：
            效率问题：需要标记的对象很多，效率不高
            空间问题：标记清除后，产生大量不连续的碎片。
    
    4.标记-整理算法
        根据老年代的特点出的一种标记算法。
        标记过程与 "标记-清除" 算法一样，但后续步骤不是直接对可回收对象回收，
        而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。
        
## 垃圾收集器
    如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
    我们要根据具体应用场景选择适合自己的垃圾收集器，因此jvm虚拟机也实现了很多的垃圾收集器。
    
    1.1 Serial收集器（-XX：+UserSerialGC  -XX：+UserSerialOldGC）
        （1）是一种串行的，最基本的垃圾收集器。
        （2）单线程收集器，工作的时候必须停止其他所有工作线程，STW（stop the workd）,直到它回收结束。用户体验不好。
        （3）新生代采用复制算法，老年代采用标记-整理算法。
        
    1.2 Parallel Scavenge收集器（-XX：+UseParallelGC【年轻代】 -XX：+UseParallelOldGc【老年代】）
        （1）parallel收集器就是serial收集器的多线程版本。
        （2）parallel Scavenge收集器的关注点是吞吐量（高效率利用CPU）。
        （3）CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。
        （4）parallel Scavenge收集器提供了很多参数供用户找到合适的停顿时间和最大吞吐量。
        
    1.3 ParNew收集器（-XX：+UseParNewGC）
        parNew收集器其实跟parallel收集器很类似。
        区别就是可以和CMS收集器配合使用。  
    
    1.4 CMS收集器(-xx:+UserConcMarkSweepGC)
        CMS收集器是一种获取最短回收停顿时间为目标的收集器，非常符合注重用户体验的应用上。
        是HtpSpot虚拟机并发收集器，实现了让垃圾收集器线程和用户线程同时工作
        
        通过 "标记-清楚" 算法实现的，过程分为四个步骤：
            （1）初始标记
            （2）并发标记
            （3）重新标记
            （4）并发清理
            （5）并发重置
            
        优点：并发收集、低停顿
        
        缺点：对CPU要求高，和服务抢资源
             标记清除算法会产生大量空间碎片
        
## 垃圾收集底层算法实现-三色标记
    
                
    
    
    
    
    
    
    
    
    
    
    
    